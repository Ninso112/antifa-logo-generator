<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Antifa Sticker Generator</title>
		<meta name="description" content="A client-side generator for creating custom antifascist stickers. Adjustable texts, positions and icons.">
		<meta name="keywords" content="antifa, sticker, generator, svg, png, designer">
		<meta name="author" content="Ninso112">
		
		<!-- PWA Meta Tags -->
		<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
		<meta name="theme-color" content="#1a1a1a" media="(prefers-color-scheme: dark)">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="default">
		<meta name="apple-mobile-web-app-title" content="Sticker Generator">
		<meta name="mobile-web-app-capable" content="yes">
		
		<!-- Manifest -->
		<link rel="manifest" href="manifest.json">
		
		<!-- Icons -->
		<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Ccircle cx='256' cy='256' r='225' stroke='black' fill='white' stroke-width='50'/%3E%3Ctext x='256' y='256' font-family='sans-serif' font-size='120' font-weight='bold' text-anchor='middle' dominant-baseline='middle' fill='black'%3EA%3C/text%3E%3C/svg%3E">
		<link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Ccircle cx='256' cy='256' r='225' stroke='black' fill='white' stroke-width='50'/%3E%3Ctext x='256' y='256' font-family='sans-serif' font-size='120' font-weight='bold' text-anchor='middle' dominant-baseline='middle' fill='black'%3EA%3C/text%3E%3C/svg%3E">
		
		<script>
			// Version
			const VERSION = 'V0.90';
		</script>
		<style>
			* {
				box-sizing: border-box;
			}
			
			:root {
				--primary-bg: #f0f0f0;
				--primary-bg-hover: #e0e0e0;
				--border-color: #333;
				--text-color: #000;
				--link-color: #0066cc;
				--body-bg: #fff;
				--input-bg: #fff;
				--input-border: #ccc;
			}
			
			[data-theme="dark"] {
				--primary-bg: #2d2d2d;
				--primary-bg-hover: #3d3d3d;
				--border-color: #ccc;
				--text-color: #e0e0e0;
				--link-color: #4da6ff;
				--body-bg: #1a1a1a;
				--input-bg: #2d2d2d;
				--input-border: #555;
			}
			
			body {
				margin: 0 auto;
				padding: 1rem;
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
				max-width: 1200px;
				color: var(--text-color);
				line-height: 1.5;
				background-color: var(--body-bg);
				transition: background-color 0.3s ease, color 0.3s ease;
			}
			
			h1 {
				margin-top: 0;
				font-size: 1.8rem;
			}
			
			a {
				color: var(--link-color);
				text-decoration: none;
			}
			
			a:hover {
				text-decoration: underline;
			}
			
			#svg-container {
				display: flex;
				justify-content: center;
				margin: 1rem 0;
			}
			
			svg {
				background: repeating-conic-gradient(#dddddd 0% 25%, #999999 0% 50%) 50% / 20px 20px;
				max-width: 100%;
				height: auto;
				display: block;
				border-radius: 4px;
				transition: filter 0.3s ease;
			}
			
			[data-theme="dark"] svg {
				filter: brightness(0.9);
			}
			
			.dark-mode-toggle {
				position: fixed;
				top: 1rem;
				right: 1rem;
				background: var(--primary-bg);
				border: 2px solid var(--border-color);
				border-radius: 50%;
				width: 48px;
				height: 48px;
				cursor: pointer;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 1.5rem;
				transition: background-color 0.3s ease, transform 0.2s ease;
				z-index: 1000;
				box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
			}
			
			.dark-mode-toggle:hover {
				background: var(--primary-bg-hover);
				transform: scale(1.1);
			}
			
			.dark-mode-toggle:active {
				transform: scale(0.95);
			}
			
			@media (max-width: 767px) {
				.dark-mode-toggle {
					top: 0.5rem;
					right: 0.5rem;
					width: 40px;
					height: 40px;
					font-size: 1.2rem;
				}
			}
			
			form {
				display: grid;
				grid-template-columns: 30% 1fr;
				gap: 0.75rem 1.5rem;
				align-items: center;
			}
			
			form > div {
				grid-column: 1 / -1;
				display: flex;
				flex-wrap: wrap;
				gap: 1rem;
				align-items: center;
			}
			
			label {
				font-size: 0.9rem;
				font-weight: 500;
			}
			
			input[type="text"],
			input[type="range"],
			input[type="file"],
			input[type="button"] {
				width: 100%;
				padding: 0.5rem;
			}
			
			input[type="text"] {
				border: 1px solid var(--input-border);
				border-radius: 4px;
				font-size: 1rem;
				background-color: var(--input-bg);
				color: var(--text-color);
				transition: border-color 0.3s ease, background-color 0.3s ease, color 0.3s ease;
			}
			
			input[type="text"]:focus {
				outline: 2px solid var(--link-color);
				outline-offset: 2px;
				border-color: var(--link-color);
			}
			
			input[type="range"] {
				cursor: pointer;
			}
			
			input[type="button"] {
				cursor: pointer;
				font-size: 1rem;
				border: 2px solid var(--border-color);
				background: var(--primary-bg);
				color: var(--text-color);
				border-radius: 4px;
				transition: background-color 0.3s ease, transform 0.1s, border-color 0.3s ease, color 0.3s ease;
				font-weight: 500;
				max-width: 200px;
			}
			
			input[type="button"]:hover {
				background: var(--primary-bg-hover);
			}
			
			input[type="button"]:active {
				transform: translateY(1px);
			}
			
			input[type="button"]:focus {
				outline: 2px solid var(--link-color);
				outline-offset: 2px;
			}
			
			input[type="checkbox"] {
				width: auto;
				margin-right: 0.5rem;
				cursor: pointer;
			}
			
			input[type="file"] {
				cursor: pointer;
			}
			
			input:disabled {
				opacity: 0.6;
				cursor: not-allowed;
			}
			
			input[type="range"] {
				accent-color: var(--link-color);
			}
			
			[data-theme="dark"] form {
				background-color: transparent;
			}
			
			/* Mobile Styles */
			@media (max-width: 767px) {
				body {
					padding: 0.5rem;
				}
				
				h1 {
					font-size: 1.5rem;
					text-align: center;
				}
				
				p {
					text-align: center;
					font-size: 0.9rem;
				}
				
				#svg-container {
					margin: 0.5rem 0;
				}
				
				svg {
					width: 100%;
					max-width: 100vw;
				}
				
				form {
					grid-template-columns: 1fr;
					gap: 0.75rem;
				}
				
				form > div {
					flex-direction: column;
					align-items: flex-start;
					gap: 0.75rem;
				}
				
				label {
					font-size: 0.95rem;
					width: 100%;
				}
				
				input[type="text"],
				input[type="range"],
				input[type="file"],
				input[type="button"] {
					padding: 0.75rem;
					font-size: 1rem;
					min-height: 44px;
				}
				
				input[type="button"] {
					max-width: none;
					margin-top: 0.5rem;
				}
				
				input[type="checkbox"] + label {
					display: inline;
					width: auto;
				}
			}
		</style>
	</head>
	<body>
		<button class="dark-mode-toggle" id="dark-mode-toggle" aria-label="Toggle dark mode" title="Toggle dark mode">
			ðŸŒ™
		</button>
		<h1 id="version-header">Antifa Sticker Generator</h1>
		<p>
			A purely client-side sticker generator. <a href="https://github.com/Ninso112/antifa-logo-generator" rel="noopener noreferrer" target="_blank" aria-label="View source code on GitHub">Source Code</a>.
		</p>
		<div id="svg-container">
			<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 500 500" width="500" height="500" id="svg" role="img" aria-labelledby="svgTitle svgDesc">
			<title id="svgTitle">Antifa Sticker</title>
			<desc id="svgDesc">Generated sticker design â€” customizable and exportable as SVG/PNG.</desc>
			<defs>
				<filter id="black">
					<feColorMatrix in="SourceGraphic" type="matrix"
						values="1 0 0 0 0
						0 1 0 0 0
						0 0 1 0 0
						0 0 0 1 0" />
				</filter>
				<filter id="red">
					<feColorMatrix in="SourceGraphic" type="matrix"
						values="1 1 1 1 0
						0 0 0 0 0
						0 0 0 0 0
						0 0 0 1 0" />
				</filter>
			</defs>
			<g id="svgroot" transform="scale(1, 1)">
				<circle id="bleed" cx="250" cy="250" r="249" stroke="#ff00ff" fill="none" stroke-width="0" />
				<circle cx="250" cy="250" r="225" stroke="black" fill="white" stroke-width="50" />
				<g id="icon">
					<image transform="translate(0 0) translate(-9 -2) scale(1, 1)" id="iconred" xlink:href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB3aWR0aD0iNTEycHgiCiAgICAgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiPgogIDxwYXRoIGZpbGw9IiMwMDAwMDAiIGQ9Ik0xMjUuNjY3LDEyMi45MTdjMCwwLDI4LDMzLjA4Myw4OS4yNSwzNC4zMzNjNjEuMjUxLDEuMjUsOTUuOTE3LTM3LjkxNywxMzAuOTE3LTMzLjMzM3M2Myw0My4zMzMsNzcuNzUsNTAuMTY3TDMzMyw0MjUuNzUKICAgICAgICBjMCwwLTEuODMzLDEuMzM0LTExLDQuNjY3cy0xMS4zMzMsNC4zMzMtMTEuMzMzLDQuMzMzbDQwLjI1LTEyMi45MTdjMCwwLTM4Ljc1LTMyLjY4Ny03My43NS0zNQogICAgICAgIGMtMzUuMDAxLTIuMzEzLTUwLjkxNywyMy43NS0xMTAuMDgzLDEzLjc1QzEwNy45MTcsMjgwLjU4Myw2OS41LDI0My41LDY5LjUsMjQzLjVzLTEuNDE1LTIxLjA2NywxNC41LTU5LjgzMwogICAgICAgIEM5OS45MTQsMTQ0LjkwMiwxMjUuNjY3LDEyMi45MTcsMTI1LjY2NywxMjIuOTE3eiIvPgo8L3N2Zz4K" width="512" height="512" filter="url(#red)" />
					<image transform="translate(0 0) translate(-9 -2) scale(1, 1)" id="iconblack" xlink:href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB3aWR0aD0iNTEycHgiCiAgICAgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiPgogIDxwYXRoIGZpbGw9IiMwMDAwMDAiIGQ9Ik02OS45MTcsMjUxLjI1YzAsMCw0MS4wODQsMzguNDE2LDEwMi40MTcsNDYuMDgzYzYxLjMzMiw3LjY2Nyw2Ny4wMzktMTQuNDkxLDEwMC45MTYtMTQuMjUKICAgICAgICBjMjEuNTQ4LDAuMTUzLDI5LjMzNCw5LjU4NCwyOS4zMzQsOS41ODRsLTUzLjUwNiwxNDkuNjdjMCwwLTQuMTgtMC4wNDQtMTAuMDkyLTAuNjkyYy01LjkxMS0wLjY0OC05LjU0MS0xLjI5NC05LjU0MS0xLjI5NAogICAgICAgIEwyNTcsMzU3LjVjMCwwLTEzLjU4NC04LjcwNy0yNy4yNS0xMC41Yy0xMy42NjgtMS43OTMtMjEuMDQyLDMtNDYuNSwyLjVjLTI0LjA3My0wLjQ3My03MS4yNS0xMi43NS05My4zMzMtNDUuNzUKICAgICAgICBTNjkuOTE3LDI1MS4yNSw2OS45MTcsMjUxLjI1eiIvPgo8L3N2Zz4K" width="512" height="512" filter="url(#black)" />
				</g>
				<path id="upper" stroke="none" fill="none" d="M 250 460 A 210 210 0 0 1 250 40 A 210 210 0 1 1 250 460"/>
				<path id="lower" stroke="none" fill="none" d="M 250 10 A 240 240 0 1 0 250 490 A 210 210 0 0 0 250 10"/>
				<text style="fill: white; font-family: sans-serif; font-weight: bold; font-size: 40px; text-align: center; text-anchor: middle;"><textPath id="uppertext" startOffset="50%" xlink:href="#upper">ANTIFASCHISTISCHE</textPath></text>
				<text style="fill: white; font-family: sans-serif; font-weight: bold; font-size: 40px; text-align: center; text-anchor: middle;"><textPath id="lowertext" startOffset="50%" xlink:href="#lower">AKTION</textPath></text>
			</g>
		</svg>
		</div>
		<form>
			<label for="input-text-upper">Upper text</label>
			<input type="text" id="input-text-upper" name="upper" value="ANTIFASCHISTISCHE" aria-label="Upper text of the sticker">
			<label for="input-text-lower">Lower text</label>
			<input type="text" id="input-text-lower" name="lower" value="AKTION" aria-label="Lower text of the sticker">
			<label for="input-range-position-x">X Position</label>
			<input type="range" id="input-range-position-x" name="position-x" value="-9" min="-500" max="500" aria-label="X position of the icon">
			<label for="input-range-position-y">Y Position</label>
			<input type="range" id="input-range-position-y" name="position-y" value="-2" min="-500" max="500" aria-label="Y position of the icon">
			<label for="input-range-shift-x">X Shift</label>
			<input type="range" id="input-range-shift-x" name="distance-x" value="0" min="-250" max="250" aria-label="X offset between red and black icon">
			<label for="input-range-shift-y">Y Shift</label>
			<input type="range" id="input-range-shift-y" name="distance-y" value="0" min="-250" max="250" aria-label="Y offset between red and black icon">
			<label for="input-range-scale-black">Black Scale</label>
			<input type="range" id="input-range-scale-black" name="scale-black" value="0" min="-3" max="3" step="0.01" aria-label="Scale factor for black icon">
			<label for="input-range-scale-red">Red Scale</label>
			<input type="range" id="input-range-scale-red" name="scale-red" value="0" min="-3" max="3" step="0.01" aria-label="Scale factor for red icon">
			<label for="input-file-icon-black">Black Icon (black+white+alpha only)</label>
			<input type="file" id="input-file-icon-black" name="icon-black" accept="image/*" aria-label="Upload black icon">
			<label for="input-file-icon-red">Red Icon (black+white+alpha only)</label>
			<input type="file" id="input-file-icon-red" name="icon-red" accept="image/*" aria-label="Upload red icon">
			<label for="input-range-bleed">Bleed (black in download)</label>
			<input type="range" id="input-range-bleed" name="bleed" value="0" min="0" max="50" aria-label="Bleed for printing">
			<div>
				<input type="checkbox" id="input-check-swap-red-black" name="swap-red-black" aria-label="Red on top of black">
				<label for="input-check-swap-red-black">Red on top of black</label>
				<input type="checkbox" id="input-check-lock-scale" name="lock-scale" aria-label="Same scale for red and black">
				<label for="input-check-lock-scale">Same scale for red and black</label>
			</div>
			<div>
				<input type="button" id="input-button-download" value="Download SVG" aria-label="Download sticker as SVG">
				<input type="button" id="input-button-download-png" value="Download PNG" aria-label="Download sticker as PNG">
				<input type="button" id="input-button-reset" value="Reset Positions" aria-label="Reset all positions and scales to default values">
			</div>
			<label for="input-file-import-svg">Import downloaded SVG</label>
			<input type="file" id="input-file-import-svg" name="import-svg" accept="image/svg+xml" aria-label="Import previously downloaded SVG">
		</form>
		<script>
			'use strict';
			
			// Constants
			const XLINK_NS = 'http://www.w3.org/1999/xlink';
			const DEFAULT_SIZE = 500;
			const DEFAULT_ICON_SIZE = 512;
			const DEBOUNCE_DELAY = 16; // ~60fps
			
			// Default values
			const DEFAULTS = {
				textUpper: 'ANTIFASCHISTISCHE',
				textLower: 'AKTION',
				positionX: -9,
				positionY: -2,
				shiftX: 0,
				shiftY: 0,
				scaleBlack: 0,
				scaleRed: 0,
				bleed: 0,
				scaleFactor: 1, // scale value 0 = 10^0 = 1
				pngDefaultSize: 2048,
				pngMaxSize: 8192
			};
			
			// Helper: Convert scale input to actual scale value
			const scaleValueToNumber = (scaleInput) => Math.pow(10, Number(scaleInput));
			
			// Stroke colors for bleed circle
			const BLEED_STROKE_DEFAULT = '#ff00ff';
			const BLEED_STROKE_EXPORT = 'black';

			// DOM elements
			const doc = document.getElementById('svg');
			if (!doc) throw new Error('SVG element not found');
			
			const svgRoot = doc.getElementById("svgroot");
			const iconContainer = doc.getElementById("icon");
			const iconBlack = doc.getElementById("iconblack");
			const iconRed = doc.getElementById("iconred");
			const upperText = doc.getElementById("uppertext");
			const lowerText = doc.getElementById("lowertext");
			const bleedCircle = doc.getElementById("bleed");
			
			if (!svgRoot || !iconContainer || !iconBlack || !iconRed || !upperText || !lowerText || !bleedCircle) {
				throw new Error('Required SVG elements not found');
			}
			
			// Debounce helper
			function debounce(func, wait) {
				let timeout;
				return function executedFunction(...args) {
					const later = () => {
						clearTimeout(timeout);
						func(...args);
					};
					clearTimeout(timeout);
					timeout = setTimeout(later, wait);
				};
			}

			// Set version in header
			const versionHeader = document.getElementById('version-header');
			if (versionHeader) {
				versionHeader.textContent = `Antifa Sticker Generator ${VERSION}`;
			}

			// Dark mode functionality
			const darkModeToggle = document.getElementById('dark-mode-toggle');
			const STORAGE_KEY = 'darkMode';
			const THEME_ATTRIBUTE = 'data-theme';
			
			function initDarkMode() {
				const savedTheme = localStorage.getItem(STORAGE_KEY);
				const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
				const isDark = savedTheme === 'dark' || (!savedTheme && prefersDark);
				setDarkMode(isDark);
			}
			
			function setDarkMode(isDark) {
				if (isDark) {
					document.documentElement.setAttribute(THEME_ATTRIBUTE, 'dark');
					if (darkModeToggle) darkModeToggle.textContent = 'â˜€ï¸';
					localStorage.setItem(STORAGE_KEY, 'dark');
				} else {
					document.documentElement.removeAttribute(THEME_ATTRIBUTE);
					if (darkModeToggle) darkModeToggle.textContent = 'ðŸŒ™';
					localStorage.setItem(STORAGE_KEY, 'light');
				}
			}
			
			function toggleDarkMode() {
				const isDark = document.documentElement.getAttribute(THEME_ATTRIBUTE) === 'dark';
				setDarkMode(!isDark);
			}
			
			// Initialize dark mode on page load
			initDarkMode();
			
			// Add click handler
			if (darkModeToggle) {
				darkModeToggle.addEventListener('click', toggleDarkMode);
			}
			
			// Listen for system theme changes
			window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
				if (!localStorage.getItem(STORAGE_KEY)) {
					setDarkMode(e.matches);
				}
			});

			// Service Worker Registration for PWA
			if ('serviceWorker' in navigator) {
				window.addEventListener('load', () => {
					navigator.serviceWorker.register('./sw.js', { scope: './' })
						.then((registration) => {
							// Check for updates
							registration.addEventListener('updatefound', () => {
								const newWorker = registration.installing;
								if (!newWorker) return;
								
								newWorker.addEventListener('statechange', () => {
									if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
										// New service worker available, prompt user to reload
										if (confirm('New version available. Reload to update?')) {
											window.location.reload();
										}
									}
								});
							});
							
							// Check for updates periodically
							setInterval(() => {
								registration.update();
							}, 60000); // Check every minute
						})
						.catch(() => {
							// Silent fail - app works without service worker
						});
				});
			}

			// Input elements - safely get all inputs with null checks
			const getElementById = (id) => document.getElementById(id);
			const inputs = {
				textUpper: getElementById("input-text-upper"),
				textLower: getElementById("input-text-lower"),
				positionX: getElementById("input-range-position-x"),
				positionY: getElementById("input-range-position-y"),
				shiftX: getElementById("input-range-shift-x"),
				shiftY: getElementById("input-range-shift-y"),
				scaleBlack: getElementById("input-range-scale-black"),
				scaleRed: getElementById("input-range-scale-red"),
				fileIconBlack: getElementById("input-file-icon-black"),
				fileIconRed: getElementById("input-file-icon-red"),
				checkSwap: getElementById("input-check-swap-red-black"),
				checkLockScale: getElementById("input-check-lock-scale"),
				bleed: getElementById("input-range-bleed"),
				buttonDownload: getElementById("input-button-download"),
				buttonDownloadPng: getElementById("input-button-download-png"),
				fileImportSvg: getElementById("input-file-import-svg"),
				buttonReset: getElementById("input-button-reset")
			};

			// Helper functions
			function setImageHref(imgElement, dataUrl, width, height) {
				if (!imgElement) return;
				imgElement.href.baseVal = dataUrl;
				imgElement.setAttributeNS(XLINK_NS, 'href', dataUrl);
				if (width) imgElement.width.baseVal.value = width;
				if (height) imgElement.height.baseVal.value = height;
			}

			// Transform update helpers
			function getIconTransform(iconElement, index) {
				if (!iconElement || iconElement.transform.baseVal.numberOfItems <= index) return null;
				return iconElement.transform.baseVal[index].matrix;
			}

			function updateIconPosition(iconElement, x, y) {
				const matrix = getIconTransform(iconElement, 1);
				if (!matrix) return;
				matrix.e = x;
				matrix.f = y;
			}

			function updateIconShift(iconElement, x, y, invert = false) {
				const matrix = getIconTransform(iconElement, 0);
				if (!matrix) return;
				matrix.e = invert ? -x : x;
				matrix.f = invert ? -y : y;
			}

			function updateIconScale(iconElement, scale) {
				const matrix = getIconTransform(iconElement, 2);
				if (!matrix) return;
				matrix.a = scale;
				matrix.d = scale;
			}

			function getIconPosition(iconElement) {
				const matrix = getIconTransform(iconElement, 1);
				return matrix ? { x: matrix.e, y: matrix.f } : { x: 0, y: 0 };
			}

			function getIconShift(iconElement) {
				const matrix = getIconTransform(iconElement, 0);
				return matrix ? { x: matrix.e, y: matrix.f } : { x: 0, y: 0 };
			}

			function updateBleed(bleedVal) {
				if (!bleedCircle || !doc) return;
				bleedCircle.style.strokeWidth = bleedVal === 0 ? 0 : bleedVal * 2 + 1;
				const size = DEFAULT_SIZE + bleedVal * 2;
				doc.width.baseVal.value = size;
				doc.height.baseVal.value = size;
				doc.viewBox.baseVal.x = -bleedVal;
				doc.viewBox.baseVal.y = -bleedVal;
				doc.viewBox.baseVal.width = size;
				doc.viewBox.baseVal.height = size;
			}

			function resizeSvg(size, offset) {
				if (!doc || !svgRoot) return;
				const scale = size / DEFAULT_SIZE;
				doc.width.baseVal.value = size;
				doc.height.baseVal.value = size;
				doc.viewBox.baseVal.width = size;
				doc.viewBox.baseVal.height = size;
				doc.viewBox.baseVal.x = offset;
				doc.viewBox.baseVal.y = offset;
				if (svgRoot.transform.baseVal.numberOfItems > 0) {
					const matrix = svgRoot.transform.baseVal[0].matrix;
					matrix.a = scale;
					matrix.d = scale;
				}
			}

			function restoreSvgSize(originalSize, originalOffset) {
				if (!doc || !svgRoot) return;
				doc.width.baseVal.value = originalSize;
				doc.height.baseVal.value = originalSize;
				doc.viewBox.baseVal.width = originalSize;
				doc.viewBox.baseVal.height = originalSize;
				doc.viewBox.baseVal.x = originalOffset;
				doc.viewBox.baseVal.y = originalOffset;
				if (svgRoot.transform.baseVal.numberOfItems > 0) {
					svgRoot.transform.baseVal[0].matrix.a = 1;
					svgRoot.transform.baseVal[0].matrix.d = 1;
				}
			}

			function loadImageFile(file, targetElement) {
				if (!file || !targetElement) return;
				
				// Validate file type
				if (!file.type.startsWith('image/')) {
					alert('Please select a valid image file.');
					return;
				}
				
				const reader = new FileReader();
				reader.onerror = () => {
					alert('Error reading image file. Please try again.');
				};
				reader.onabort = () => {
					// File read was cancelled, silently handle
				};
				reader.onload = (e) => {
					if (!e.target?.result) return;
					
					const img = new Image();
					img.crossOrigin = 'anonymous';
					img.onerror = () => {
						alert('Error loading image. Please ensure it is a valid image format.');
					};
					img.onload = () => {
						const width = img.width || Number(targetElement.width?.baseVal?.value) || DEFAULT_ICON_SIZE;
						const height = img.height || Number(targetElement.height?.baseVal?.value) || DEFAULT_ICON_SIZE;
						setImageHref(targetElement, e.target.result, width, height);
					};
					img.onabort = () => {
						// Image load was cancelled
					};
					img.src = e.target.result;
				};
				reader.readAsDataURL(file);
			}

			function serializeSvg() {
				return new XMLSerializer().serializeToString(doc);
			}

			function createSvgDataUrl(svgString) {
				const xmlDeclaration = '<?xml version="1.0" encoding="utf-8"?>';
				const fullSvg = xmlDeclaration + '\n' + svgString;
				return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(fullSvg);
			}
			
			// Validate numeric input
			function isValidNumber(value, min = -Infinity, max = Infinity) {
				const num = Number(value);
				return !Number.isNaN(num) && num >= min && num <= max;
			}

			// Text input handlers
			if (inputs.textUpper) {
				inputs.textUpper.oninput = () => {
					if (upperText && inputs.textUpper) {
						upperText.textContent = inputs.textUpper.value || '';
					}
				};
			}

			if (inputs.textLower) {
				inputs.textLower.oninput = () => {
					if (lowerText && inputs.textLower) {
						lowerText.textContent = inputs.textLower.value || '';
					}
				};
			}

			// Position updates
			const updatePositionX = () => {
				if (!inputs.positionX) return;
				const value = Number(inputs.positionX.value);
				if (!isValidNumber(value)) return;
				const blackPos = getIconPosition(iconBlack);
				const redPos = getIconPosition(iconRed);
				updateIconPosition(iconBlack, value, blackPos.y);
				updateIconPosition(iconRed, value, redPos.y);
			};
			if (inputs.positionX) {
				inputs.positionX.oninput = debounce(updatePositionX, DEBOUNCE_DELAY);
			}

			const updatePositionY = () => {
				if (!inputs.positionY) return;
				const value = Number(inputs.positionY.value);
				if (!isValidNumber(value)) return;
				const blackPos = getIconPosition(iconBlack);
				const redPos = getIconPosition(iconRed);
				updateIconPosition(iconBlack, blackPos.x, value);
				updateIconPosition(iconRed, redPos.x, value);
			};
			if (inputs.positionY) {
				inputs.positionY.oninput = debounce(updatePositionY, DEBOUNCE_DELAY);
			}

			// Shift updates
			const updateShiftX = () => {
				if (!inputs.shiftX) return;
				const value = Number(inputs.shiftX.value);
				if (!isValidNumber(value)) return;
				const blackShift = getIconShift(iconBlack);
				const redShift = getIconShift(iconRed);
				updateIconShift(iconBlack, value, blackShift.y, false);
				updateIconShift(iconRed, value, redShift.y, true);
			};
			if (inputs.shiftX) {
				inputs.shiftX.oninput = debounce(updateShiftX, DEBOUNCE_DELAY);
			}

			const updateShiftY = () => {
				if (!inputs.shiftY) return;
				const value = Number(inputs.shiftY.value);
				if (!isValidNumber(value)) return;
				const blackShift = getIconShift(iconBlack);
				const redShift = getIconShift(iconRed);
				updateIconShift(iconBlack, blackShift.x, value, false);
				updateIconShift(iconRed, redShift.x, value, true);
			};
			if (inputs.shiftY) {
				inputs.shiftY.oninput = debounce(updateShiftY, DEBOUNCE_DELAY);
			}

			// Scale updates
			const updateScaleBlack = () => {
				if (!inputs.scaleBlack) return;
				const scale = scaleValueToNumber(inputs.scaleBlack.value);
				updateIconScale(iconBlack, scale);
				if (inputs.checkLockScale?.checked) {
					updateIconScale(iconRed, scale);
				}
			};
			if (inputs.scaleBlack) {
				inputs.scaleBlack.oninput = debounce(updateScaleBlack, DEBOUNCE_DELAY);
			}

			const updateScaleRed = () => {
				if (!inputs.scaleRed || inputs.checkLockScale?.checked) return;
				const scale = scaleValueToNumber(inputs.scaleRed.value);
				updateIconScale(iconRed, scale);
			};
			if (inputs.scaleRed) {
				inputs.scaleRed.oninput = debounce(updateScaleRed, DEBOUNCE_DELAY);
			}

			// File input handlers
			if (inputs.fileIconBlack) {
				inputs.fileIconBlack.onchange = (e) => {
					loadImageFile(e.target.files?.[0], iconBlack);
				};
			}

			if (inputs.fileIconRed) {
				inputs.fileIconRed.onchange = (e) => {
					loadImageFile(e.target.files?.[0], iconRed);
				};
			}

			// Checkbox handlers
			if (inputs.checkSwap) {
				inputs.checkSwap.onchange = () => {
					const first = inputs.checkSwap.checked ? iconBlack : iconRed;
					const second = inputs.checkSwap.checked ? iconRed : iconBlack;
					iconContainer.insertBefore(first, second);
				};
			}

			if (inputs.checkLockScale) {
				inputs.checkLockScale.onchange = () => {
					if (inputs.scaleRed) {
						inputs.scaleRed.disabled = inputs.checkLockScale.checked;
					}
					if (inputs.checkLockScale.checked && inputs.scaleBlack) {
						const scale = scaleValueToNumber(inputs.scaleBlack.value);
						updateIconScale(iconRed, scale);
					} else if (inputs.scaleRed) {
						const redScale = scaleValueToNumber(inputs.scaleRed.value);
						updateIconScale(iconRed, redScale);
					}
				};
			}

			// Bleed handler
			const updateBleedHandler = () => {
				if (inputs.bleed) {
					updateBleed(parseInt(inputs.bleed.value, 10));
				}
			};
			if (inputs.bleed) {
				inputs.bleed.oninput = debounce(updateBleedHandler, DEBOUNCE_DELAY);
			}

			// Reset function
			function resetPositions() {
				// Reset text values
				if (inputs.textUpper) {
					inputs.textUpper.value = DEFAULTS.textUpper;
					if (upperText) upperText.textContent = DEFAULTS.textUpper;
				}
				if (inputs.textLower) {
					inputs.textLower.value = DEFAULTS.textLower;
					if (lowerText) lowerText.textContent = DEFAULTS.textLower;
				}

				// Reset positions
				if (inputs.positionX) inputs.positionX.value = DEFAULTS.positionX;
				if (inputs.positionY) inputs.positionY.value = DEFAULTS.positionY;
				updateIconPosition(iconBlack, DEFAULTS.positionX, DEFAULTS.positionY);
				updateIconPosition(iconRed, DEFAULTS.positionX, DEFAULTS.positionY);

				// Reset shifts
				if (inputs.shiftX) inputs.shiftX.value = DEFAULTS.shiftX;
				if (inputs.shiftY) inputs.shiftY.value = DEFAULTS.shiftY;
				updateIconShift(iconBlack, DEFAULTS.shiftX, DEFAULTS.shiftY, false);
				updateIconShift(iconRed, DEFAULTS.shiftX, DEFAULTS.shiftY, true);

				// Reset scales
				if (inputs.scaleBlack) {
					inputs.scaleBlack.value = DEFAULTS.scaleBlack;
					updateIconScale(iconBlack, DEFAULTS.scaleFactor);
				}
				if (inputs.scaleRed) {
					inputs.scaleRed.value = DEFAULTS.scaleRed;
					updateIconScale(iconRed, DEFAULTS.scaleFactor);
				}

				// Reset bleed
				if (inputs.bleed) {
					inputs.bleed.value = DEFAULTS.bleed;
					updateBleed(DEFAULTS.bleed);
				}

				// Reset checkboxes
				if (inputs.checkSwap) {
					inputs.checkSwap.checked = false;
					iconContainer.insertBefore(iconRed, iconBlack);
				}
				if (inputs.checkLockScale) {
					inputs.checkLockScale.checked = false;
					if (inputs.scaleRed) inputs.scaleRed.disabled = false;
				}
			}

			// Download helpers
			function downloadFile(dataUrl, filename) {
				const link = document.createElement('a');
				link.href = dataUrl;
				link.download = filename;
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
			}

			// Download handlers
			if (inputs.buttonDownload) {
				inputs.buttonDownload.onclick = () => {
					bleedCircle.style.stroke = BLEED_STROKE_EXPORT;
					const serialized = serializeSvg();
					bleedCircle.style.stroke = BLEED_STROKE_DEFAULT;
					downloadFile(createSvgDataUrl(serialized), 'antifa.svg');
				};
			}

			// Reset handler
			if (inputs.buttonReset) {
				inputs.buttonReset.onclick = () => {
					resetPositions();
				};
			}

			if (inputs.buttonDownloadPng) {
				inputs.buttonDownloadPng.onclick = async () => {
				const originalSize = Number(doc.width.baseVal.value);
				const originalOffset = Number(doc.viewBox.baseVal.x);
				const imgSizeInput = prompt(`Enter image size (e.g. ${DEFAULTS.pngDefaultSize})`, String(DEFAULTS.pngDefaultSize));
				
				if (!imgSizeInput) return;
				
				const imgSize = parseInt(imgSizeInput, 10);
				if (!isValidNumber(imgSize, 1, DEFAULTS.pngMaxSize)) {
					alert(`Invalid image size. Please enter a number between 1 and ${DEFAULTS.pngMaxSize}.`);
					return;
				}

				// Resize SVG for export
				bleedCircle.style.stroke = BLEED_STROKE_EXPORT;
				const offset = originalOffset * imgSize / originalSize;
				resizeSvg(imgSize, offset);

				// Clone and inline external images
				const clone = doc.cloneNode(true);
				let failures = 0;
				const images = clone.querySelectorAll('image');
				
				for (const imgEl of images) {
					try {
						const href = imgEl.getAttributeNS(XLINK_NS, 'href') || 
						              imgEl.getAttribute('href') || 
						              imgEl.href?.baseVal;
						if (!href || href.startsWith('data:')) continue;
						
						// Create abort controller for timeout
						const controller = new AbortController();
						const timeoutId = setTimeout(() => controller.abort(), 5000);
						const resp = await fetch(href, { mode: 'cors', signal: controller.signal });
						clearTimeout(timeoutId);
						if (!resp.ok) throw new Error('fetch failed');
						const blob = await resp.blob();
						const dataUrl = await new Promise((resolve, reject) => {
							const fr = new FileReader();
							fr.onload = () => resolve(fr.result);
							fr.onerror = reject;
							fr.onabort = reject;
							fr.readAsDataURL(blob);
						});
						imgEl.setAttributeNS(XLINK_NS, 'href', dataUrl);
					} catch (e) {
						failures++;
					}
				}

				// Restore original size
				bleedCircle.style.stroke = BLEED_STROKE_DEFAULT;
				restoreSvgSize(originalSize, originalOffset);

				const serialized = new XMLSerializer().serializeToString(clone);
				
				if (failures > 0) {
					alert(`Could not inline ${failures} external image(s) due to CORS. PNG export aborted. The SVG will open in a new tab; use "Download SVG" or host images with CORS enabled to export PNG.`);
					window.open(createSvgDataUrl(serialized), '_blank');
					return;
				}

				// Render to canvas
				const canvas = document.createElement('canvas');
				canvas.width = imgSize;
				canvas.height = imgSize;
				const ctx = canvas.getContext("2d");
				const image = new Image();
				image.crossOrigin = 'anonymous';
				image.onerror = () => {
					alert('Error loading SVG image. SVG opened in new tab as fallback.');
					window.open(createSvgDataUrl(serialized), '_blank');
					restoreSvgSize(originalSize, originalOffset);
				};
				image.onload = () => {
					try {
						ctx.drawImage(image, 0, 0);
						downloadFile(canvas.toDataURL('image/png'), 'antifa.png');
					} catch (e) {
						alert('Export to PNG failed during finalization: canvas may be tainted. Opened SVG in new tab as fallback.');
						window.open(createSvgDataUrl(serialized), '_blank');
					}
				};
				image.onabort = () => {
					restoreSvgSize(originalSize, originalOffset);
				};
				image.src = createSvgDataUrl(serialized);
				};
			}

			if (inputs.fileImportSvg) {
				inputs.fileImportSvg.onchange = (e) => {
				const file = e.target.files[0];
				if (!file) return;
				
				const reader = new FileReader();
				reader.onerror = () => {
					alert('Error reading file.');
				};
				reader.onload = (e) => {
					try {
						const parser = new DOMParser();
						const imported = parser.parseFromString(e.target.result, 'image/svg+xml');
						
						// Check for parsing errors
						const parserError = imported.querySelector('parsererror');
						if (parserError) {
							alert('Error parsing SVG. Please ensure it is a valid SVG file.');
							return;
						}
					
					// Import text
					const impUpperText = imported.getElementById('uppertext');
					const impLowerText = imported.getElementById('lowertext');
					if (impUpperText) {
						inputs.textUpper.value = impUpperText.textContent;
						upperText.textContent = impUpperText.textContent;
					}
					if (impLowerText) {
						inputs.textLower.value = impLowerText.textContent;
						lowerText.textContent = impLowerText.textContent;
					}

					// Import icons
					const impIconBlack = imported.getElementById('iconblack');
					const impIconRed = imported.getElementById('iconred');
					if (impIconBlack) {
						const href = impIconBlack.href.baseVal;
						setImageHref(iconBlack, href);
					}
					if (impIconRed) {
						const href = impIconRed.href.baseVal;
						setImageHref(iconRed, href);
					}

					// Import transforms
					if (impIconBlack && impIconBlack.transform.baseVal.numberOfItems >= 3) {
						const transforms = impIconBlack.transform.baseVal;
						// Shift
						const shiftMatrix = transforms[0].matrix;
						const shiftX = shiftMatrix.e;
						const shiftY = shiftMatrix.f;
						if (inputs.shiftX) inputs.shiftX.value = shiftX;
						if (inputs.shiftY) inputs.shiftY.value = shiftY;
						updateIconShift(iconBlack, shiftX, shiftY, false);
						updateIconShift(iconRed, shiftX, shiftY, true);
						// Position
						const posMatrix = transforms[1].matrix;
						const posX = posMatrix.e;
						const posY = posMatrix.f;
						if (inputs.positionX) inputs.positionX.value = posX;
						if (inputs.positionY) inputs.positionY.value = posY;
						updateIconPosition(iconBlack, posX, posY);
						updateIconPosition(iconRed, posX, posY);
						// Scale
						const scaleMatrix = transforms[2].matrix;
						const scaleBlack = scaleMatrix.a;
						if (inputs.scaleBlack) {
							inputs.scaleBlack.value = Math.log10(scaleBlack);
						}
						updateIconScale(iconBlack, scaleBlack);
					}
					if (impIconRed && impIconRed.transform.baseVal.numberOfItems >= 3) {
						const scaleMatrix = impIconRed.transform.baseVal[2].matrix;
						const scaleRed = scaleMatrix.a;
						if (inputs.scaleRed) {
							inputs.scaleRed.value = Math.log10(scaleRed);
						}
						updateIconScale(iconRed, scaleRed);
					}

					// Import swap order
					const impIconContainer = imported.getElementById('icon');
					if (impIconContainer && impIconContainer.children[0]?.id === 'iconblack') {
						inputs.checkSwap.checked = true;
						iconContainer.insertBefore(iconBlack, iconRed);
					} else {
						inputs.checkSwap.checked = false;
						iconContainer.insertBefore(iconRed, iconBlack);
					}

					// Import bleed
					const impBleed = imported.getElementById('bleed');
					if (impBleed) {
						const bleedVal = Math.max(parseInt(impBleed.style.strokeWidth, 10) - 1, 0);
						inputs.bleed.value = bleedVal;
						updateBleed(bleedVal);
					}
					} catch (error) {
						alert('Error importing SVG: ' + (error.message || 'Unknown error occurred'));
					}
				};
				reader.readAsText(file);
				};
			}
		</script>
	</body>
</html>
