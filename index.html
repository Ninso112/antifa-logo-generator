<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Antifa Sticker Generator</title>
		<meta name="description" content="A client-side generator for creating custom antifascist stickers. Adjustable texts, positions and icons.">
		<meta name="keywords" content="antifa, sticker, generator, svg, png, designer">
		<meta name="author" content="Ninso112">
		
		<!-- PWA Meta Tags -->
		<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
		<meta name="theme-color" content="#1a1a1a" media="(prefers-color-scheme: dark)">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="default">
		<meta name="apple-mobile-web-app-title" content="Sticker Generator">
		<meta name="mobile-web-app-capable" content="yes">
		
		<!-- Manifest -->
		<link rel="manifest" href="manifest.json">
		
		<!-- Icons -->
		<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Ccircle cx='256' cy='256' r='225' stroke='black' fill='white' stroke-width='50'/%3E%3Ctext x='256' y='256' font-family='sans-serif' font-size='120' font-weight='bold' text-anchor='middle' dominant-baseline='middle' fill='black'%3EA%3C/text%3E%3C/svg%3E">
		<link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Ccircle cx='256' cy='256' r='225' stroke='black' fill='white' stroke-width='50'/%3E%3Ctext x='256' y='256' font-family='sans-serif' font-size='120' font-weight='bold' text-anchor='middle' dominant-baseline='middle' fill='black'%3EA%3C/text%3E%3C/svg%3E">
		
		<script>
			// Version
			const VERSION = 'V0.90';
		</script>
		<style>
			* {
				box-sizing: border-box;
			}
			
			:root {
				--primary-bg: #f5f5f5;
				--primary-bg-hover: #e8e8e8;
				--secondary-bg: #ffffff;
				--border-color: #d0d0d0;
				--border-color-hover: #a0a0a0;
				--text-color: #1a1a1a;
				--text-secondary: #666;
				--link-color: #2563eb;
				--link-hover: #1d4ed8;
				--body-bg: #fafafa;
				--input-bg: #ffffff;
				--input-border: #d1d5db;
				--input-focus: #2563eb;
				--shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
				--shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
				--shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
				--radius: 8px;
				--radius-sm: 6px;
			}
			
			[data-theme="dark"] {
				--primary-bg: #1f2937;
				--primary-bg-hover: #374151;
				--secondary-bg: #111827;
				--border-color: #374151;
				--border-color-hover: #4b5563;
				--text-color: #f9fafb;
				--text-secondary: #d1d5db;
				--link-color: #60a5fa;
				--link-hover: #93c5fd;
				--body-bg: #0f172a;
				--input-bg: #1f2937;
				--input-border: #374151;
				--input-focus: #60a5fa;
				--shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
				--shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.4), 0 2px 4px -1px rgba(0, 0, 0, 0.3);
				--shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.3);
			}
			
			body {
				margin: 0 auto;
				padding: 1.5rem;
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
				max-width: 1200px;
				color: var(--text-color);
				line-height: 1.6;
				background-color: var(--body-bg);
				transition: background-color 0.3s ease, color 0.3s ease;
				min-height: 100vh;
			}
			
			header {
				margin-bottom: 2rem;
				text-align: center;
			}
			
			h1 {
				margin: 0 0 0.5rem 0;
				font-size: 2rem;
				font-weight: 700;
				letter-spacing: -0.02em;
			}
			
			header p {
				margin: 0;
				color: var(--text-secondary);
			}
			
			a {
				color: var(--link-color);
				text-decoration: none;
				transition: color 0.2s ease;
			}
			
			a:hover {
				color: var(--link-hover);
				text-decoration: underline;
			}
			
			#svg-container {
				display: flex;
				justify-content: center;
				margin: 2rem 0;
				padding: 1.5rem;
				background: var(--secondary-bg);
				border-radius: var(--radius);
				box-shadow: var(--shadow-md);
			}
			
			svg {
				background: repeating-conic-gradient(#dddddd 0% 25%, #999999 0% 50%) 50% / 20px 20px;
				max-width: 100%;
				height: auto;
				display: block;
				border-radius: var(--radius-sm);
				transition: filter 0.3s ease, transform 0.2s ease;
				touch-action: none;
				user-select: none;
				box-shadow: var(--shadow-sm);
			}
			
			svg:hover {
				transform: translateY(-2px);
				box-shadow: var(--shadow-md);
			}
			
			#icon image {
				cursor: move;
				cursor: grab;
			}
			
			#icon image:active {
				cursor: grabbing;
			}
			
			[data-theme="dark"] svg {
				filter: brightness(0.9);
			}
			
			.dark-mode-toggle {
				position: fixed;
				top: 1.5rem;
				right: 1.5rem;
				background: var(--secondary-bg);
				border: 2px solid var(--border-color);
				border-radius: 50%;
				width: 48px;
				height: 48px;
				cursor: pointer;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 1.5rem;
				transition: all 0.3s ease;
				z-index: 1000;
				box-shadow: var(--shadow-lg);
			}
			
			.dark-mode-toggle:hover {
				background: var(--primary-bg-hover);
				border-color: var(--border-color-hover);
				transform: scale(1.1) rotate(15deg);
				box-shadow: var(--shadow-lg);
			}
			
			.dark-mode-toggle:active {
				transform: scale(0.95);
			}
			
			@media (max-width: 767px) {
				.dark-mode-toggle {
					top: 0.5rem;
					right: 0.5rem;
					width: 40px;
					height: 40px;
					font-size: 1.2rem;
				}
			}
			
			form {
				display: grid;
				grid-template-columns: 200px 1fr;
				gap: 1rem 1.5rem;
				align-items: center;
				background: var(--secondary-bg);
				padding: 2rem;
				border-radius: var(--radius);
				box-shadow: var(--shadow-md);
			}
			
			form > div {
				grid-column: 1 / -1;
				display: flex;
				flex-wrap: wrap;
				gap: 1rem;
				align-items: center;
				padding-top: 1rem;
				border-top: 1px solid var(--border-color);
			}
			
			form > div:first-of-type {
				border-top: none;
				padding-top: 0;
			}
			
			.checkbox-group {
				display: flex;
				flex-wrap: wrap;
				gap: 1.5rem;
			}
			
			.checkbox-item {
				display: flex;
				align-items: center;
				padding: 0.5rem;
				border-radius: var(--radius-sm);
				transition: background 0.2s ease;
			}
			
			.checkbox-item:hover {
				background: var(--primary-bg);
			}
			
			.button-group {
				display: flex;
				flex-direction: column;
				gap: 1rem;
				width: 100%;
			}
			
			.button-row {
				display: flex;
				flex-wrap: wrap;
				gap: 1rem;
			}
			
			.button-row:first-child input[type="button"] {
				flex: 1;
				min-width: 150px;
			}
			
			label {
				font-size: 0.9rem;
				font-weight: 600;
				color: var(--text-color);
				letter-spacing: 0.01em;
			}
			
			input[type="text"],
			input[type="range"],
			input[type="file"],
			input[type="button"] {
				width: 100%;
				padding: 0.5rem;
			}
			
			input[type="text"] {
				border: 2px solid var(--input-border);
				border-radius: var(--radius-sm);
				font-size: 1rem;
				background-color: var(--input-bg);
				color: var(--text-color);
				padding: 0.75rem;
				transition: all 0.2s ease;
			}
			
			input[type="text"]:hover {
				border-color: var(--border-color-hover);
			}
			
			input[type="text"]:focus {
				outline: none;
				border-color: var(--input-focus);
				box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
			}
			
			[data-theme="dark"] input[type="text"]:focus {
				box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.2);
			}
			
			input[type="range"] {
				cursor: pointer;
				height: 8px;
				background: var(--primary-bg);
				border-radius: 4px;
			}
			
			input[type="range"]::-webkit-slider-thumb {
				appearance: none;
				width: 20px;
				height: 20px;
				border-radius: 50%;
				background: var(--link-color);
				cursor: pointer;
				box-shadow: var(--shadow-sm);
				transition: all 0.2s ease;
			}
			
			input[type="range"]::-webkit-slider-thumb:hover {
				transform: scale(1.2);
				box-shadow: var(--shadow-md);
			}
			
			input[type="range"]::-moz-range-thumb {
				width: 20px;
				height: 20px;
				border-radius: 50%;
				background: var(--link-color);
				cursor: pointer;
				border: none;
				box-shadow: var(--shadow-sm);
				transition: all 0.2s ease;
			}
			
			input[type="range"]::-moz-range-thumb:hover {
				transform: scale(1.2);
				box-shadow: var(--shadow-md);
			}
			
			input[type="button"] {
				cursor: pointer;
				font-size: 0.95rem;
				border: 2px solid var(--link-color);
				background: var(--link-color);
				color: white;
				border-radius: var(--radius-sm);
				transition: all 0.2s ease;
				font-weight: 600;
				padding: 0.75rem 1.5rem;
				max-width: 200px;
				box-shadow: var(--shadow-sm);
			}
			
			input[type="button"]:hover {
				background: var(--link-hover);
				border-color: var(--link-hover);
				transform: translateY(-2px);
				box-shadow: var(--shadow-md);
			}
			
			input[type="button"]:active {
				transform: translateY(0);
				box-shadow: var(--shadow-sm);
			}
			
			input[type="button"]:focus {
				outline: none;
				box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.3), var(--shadow-md);
			}
			
			[data-theme="dark"] input[type="button"]:focus {
				box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.3), var(--shadow-md);
			}
			
			/* Special button styles */
			input[type="button"]#input-button-reset {
				background: var(--secondary-bg);
				color: var(--text-color);
				border-color: var(--border-color);
			}
			
			input[type="button"]#input-button-reset:hover {
				background: var(--primary-bg-hover);
				border-color: var(--border-color-hover);
				color: var(--text-color);
			}
			
			input[type="button"]#input-button-save {
				background: #10b981;
				border-color: #10b981;
			}
			
			input[type="button"]#input-button-save:hover {
				background: #059669;
				border-color: #059669;
			}
			
			input[type="button"]#input-button-load {
				background: #f59e0b;
				border-color: #f59e0b;
			}
			
			input[type="button"]#input-button-load:hover {
				background: #d97706;
				border-color: #d97706;
			}
			
			input[type="checkbox"] {
				width: 20px;
				height: 20px;
				margin-right: 0.75rem;
				cursor: pointer;
				accent-color: var(--link-color);
				transform: scale(1.1);
			}
			
			input[type="checkbox"] + label {
				cursor: pointer;
				user-select: none;
			}
			
			input[type="file"] {
				cursor: pointer;
				padding: 0.5rem;
				border: 2px dashed var(--border-color);
				border-radius: var(--radius-sm);
				background: var(--input-bg);
				transition: all 0.2s ease;
			}
			
			input[type="file"]:hover {
				border-color: var(--link-color);
				background: var(--primary-bg);
			}
			
			input[type="file"]::file-selector-button {
				padding: 0.5rem 1rem;
				margin-right: 1rem;
				border: none;
				border-radius: var(--radius-sm);
				background: var(--link-color);
				color: white;
				cursor: pointer;
				font-weight: 600;
				transition: background 0.2s ease;
			}
			
			input[type="file"]::file-selector-button:hover {
				background: var(--link-hover);
			}
			
			input:disabled {
				opacity: 0.6;
				cursor: not-allowed;
			}
			
			input[type="range"] {
				accent-color: var(--link-color);
			}
			
			[data-theme="dark"] form {
				background-color: var(--secondary-bg);
			}
			
			/* Mobile Styles */
			@media (max-width: 767px) {
				body {
					padding: 1rem;
				}
				
				h1 {
					font-size: 1.75rem;
					text-align: center;
					margin-bottom: 0.75rem;
				}
				
				p {
					text-align: center;
					font-size: 0.9rem;
					margin-bottom: 1.5rem;
				}
				
				#svg-container {
					margin: 1rem 0;
					padding: 1rem;
				}
				
				svg {
					width: 100%;
					max-width: 100vw;
					touch-action: pan-x pan-y;
				}
				
				svg:hover {
					transform: none;
				}
				
				form {
					grid-template-columns: 1fr;
					gap: 1.25rem;
					padding: 1.5rem;
				}
				
				form > div {
					flex-direction: column;
					align-items: stretch;
					gap: 1rem;
					padding-top: 1.25rem;
				}
				
				label {
					font-size: 0.95rem;
					width: 100%;
					margin-bottom: 0.5rem;
				}
				
				input[type="text"],
				input[type="range"],
				input[type="file"],
				input[type="button"] {
					padding: 0.875rem;
					font-size: 1rem;
					min-height: 48px;
				}
				
				input[type="button"] {
					max-width: none;
					width: 100%;
					margin-top: 0.5rem;
				}
				
				.checkbox-group {
					flex-direction: column;
					gap: 1rem;
				}
				
				.button-row {
					flex-direction: column;
				}
				
				.dark-mode-toggle {
					top: 0.75rem;
					right: 0.75rem;
					width: 44px;
					height: 44px;
					font-size: 1.3rem;
				}
			}
			
			/* Tablet Styles */
			@media (min-width: 768px) and (max-width: 1024px) {
				body {
					padding: 1.5rem;
				}
				
				header {
					text-align: left;
				}
				
				form {
					grid-template-columns: 180px 1fr;
					gap: 1rem 1.25rem;
					padding: 1.75rem;
				}
				
				.button-row:first-child input[type="button"] {
					min-width: 140px;
				}
				
				input[type="button"] {
					font-size: 0.9rem;
					padding: 0.7rem 1.25rem;
				}
			}
			
			/* Large Desktop */
			@media (min-width: 1025px) {
				header {
					text-align: left;
				}
			}
			
			@media (min-width: 1400px) {
				body {
					max-width: 1400px;
				}
				
				form {
					padding: 2.5rem;
				}
			}
		</style>
	</head>
	<body>
		<button class="dark-mode-toggle" id="dark-mode-toggle" aria-label="Toggle dark mode" title="Toggle dark mode">
			ðŸŒ™
		</button>
		<header>
			<h1 id="version-header">Antifa Sticker Generator</h1>
			<p>
				A purely client-side sticker generator. <a href="https://github.com/Ninso112/antifa-logo-generator" rel="noopener noreferrer" target="_blank" aria-label="View source code on GitHub">Source Code</a>. <a rel="me" href="https://mastodon.social/@Ninso" target="_blank" aria-label="Follow on Mastodon">Mastodon</a>.
			</p>
		</header>
		<div id="svg-container">
			<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 500 500" width="500" height="500" id="svg" role="img" aria-labelledby="svgTitle svgDesc">
			<title id="svgTitle">Antifa Sticker</title>
			<desc id="svgDesc">Generated sticker design â€” customizable and exportable as SVG/PNG.</desc>
			<defs>
				<filter id="black">
					<feColorMatrix in="SourceGraphic" type="matrix"
						values="1 0 0 0 0
						0 1 0 0 0
						0 0 1 0 0
						0 0 0 1 0" />
				</filter>
				<filter id="red">
					<feColorMatrix in="SourceGraphic" type="matrix"
						values="1 1 1 1 0
						0 0 0 0 0
						0 0 0 0 0
						0 0 0 1 0" />
				</filter>
			</defs>
			<g id="svgroot" transform="scale(1, 1)">
				<circle id="bleed" cx="250" cy="250" r="249" stroke="#ff00ff" fill="none" stroke-width="0" />
				<circle cx="250" cy="250" r="225" stroke="black" fill="white" stroke-width="50" />
				<g id="icon">
					<image transform="translate(0 0) translate(-9 -2) scale(1, 1)" id="iconred" xlink:href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB3aWR0aD0iNTEycHgiCiAgICAgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiPgogIDxwYXRoIGZpbGw9IiMwMDAwMDAiIGQ9Ik0xMjUuNjY3LDEyMi45MTdjMCwwLDI4LDMzLjA4Myw4OS4yNSwzNC4zMzNjNjEuMjUxLDEuMjUsOTUuOTE3LTM3LjkxNywxMzAuOTE3LTMzLjMzM3M2Myw0My4zMzMsNzcuNzUsNTAuMTY3TDMzMyw0MjUuNzUKICAgICAgICBjMCwwLTEuODMzLDEuMzM0LTExLDQuNjY3cy0xMS4zMzMsNC4zMzMtMTEuMzMzLDQuMzMzbDQwLjI1LTEyMi45MTdjMCwwLTM4Ljc1LTMyLjY4Ny03My43NS0zNQogICAgICAgIGMtMzUuMDAxLTIuMzEzLTUwLjkxNywyMy43NS0xMTAuMDgzLDEzLjc1QzEwNy45MTcsMjgwLjU4Myw2OS41LDI0My41LDY5LjUsMjQzLjVzLTEuNDE1LTIxLjA2NywxNC41LTU5LjgzMwogICAgICAgIEM5OS45MTQsMTQ0LjkwMiwxMjUuNjY3LDEyMi45MTcsMTI1LjY2NywxMjIuOTE3eiIvPgo8L3N2Zz4K" width="512" height="512" filter="url(#red)" />
					<image transform="translate(0 0) translate(-9 -2) scale(1, 1)" id="iconblack" xlink:href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB3aWR0aD0iNTEycHgiCiAgICAgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiPgogIDxwYXRoIGZpbGw9IiMwMDAwMDAiIGQ9Ik02OS45MTcsMjUxLjI1YzAsMCw0MS4wODQsMzguNDE2LDEwMi40MTcsNDYuMDgzYzYxLjMzMiw3LjY2Nyw2Ny4wMzktMTQuNDkxLDEwMC45MTYtMTQuMjUKICAgICAgICBjMjEuNTQ4LDAuMTUzLDI5LjMzNCw5LjU4NCwyOS4zMzQsOS41ODRsLTUzLjUwNiwxNDkuNjdjMCwwLTQuMTgtMC4wNDQtMTAuMDkyLTAuNjkyYy01LjkxMS0wLjY0OC05LjU0MS0xLjI5NC05LjU0MS0xLjI5NAogICAgICAgIEwyNTcsMzU3LjVjMCwwLTEzLjU4NC04LjcwNy0yNy4yNS0xMC41Yy0xMy42NjgtMS43OTMtMjEuMDQyLDMtNDYuNSwyLjVjLTI0LjA3My0wLjQ3My03MS4yNS0xMi43NS05My4zMzMtNDUuNzUKICAgICAgICBTNjkuOTE3LDI1MS4yNSw2OS45MTcsMjUxLjI1eiIvPgo8L3N2Zz4K" width="512" height="512" filter="url(#black)" />
				</g>
				<path id="upper" stroke="none" fill="none" d="M 250 460 A 210 210 0 0 1 250 40 A 210 210 0 1 1 250 460"/>
				<path id="lower" stroke="none" fill="none" d="M 250 10 A 240 240 0 1 0 250 490 A 210 210 0 0 0 250 10"/>
				<text style="fill: white; font-family: sans-serif; font-weight: bold; font-size: 40px; text-align: center; text-anchor: middle;"><textPath id="uppertext" startOffset="50%" xlink:href="#upper">ANTIFASCHISTISCHE</textPath></text>
				<text style="fill: white; font-family: sans-serif; font-weight: bold; font-size: 40px; text-align: center; text-anchor: middle;"><textPath id="lowertext" startOffset="50%" xlink:href="#lower">AKTION</textPath></text>
			</g>
		</svg>
		</div>
		<form>
			<label for="input-text-upper">Upper text</label>
			<input type="text" id="input-text-upper" name="upper" value="ANTIFASCHISTISCHE" aria-label="Upper text of the sticker">
			<label for="input-text-lower">Lower text</label>
			<input type="text" id="input-text-lower" name="lower" value="AKTION" aria-label="Lower text of the sticker">
			<label for="input-range-position-x">X Position</label>
			<input type="range" id="input-range-position-x" name="position-x" value="-9" min="-500" max="500" aria-label="X position of the icon" title="Horizontal position of both icons (drag icons or use slider)">
			<label for="input-range-position-y">Y Position</label>
			<input type="range" id="input-range-position-y" name="position-y" value="-2" min="-500" max="500" aria-label="Y position of the icon" title="Vertical position of both icons (drag icons or use slider)">
			<label for="input-range-shift-x">X Shift</label>
			<input type="range" id="input-range-shift-x" name="distance-x" value="0" min="-250" max="250" aria-label="X offset between red and black icon" title="Horizontal offset between red and black icons (positive = black right, red left)">
			<label for="input-range-shift-y">Y Shift</label>
			<input type="range" id="input-range-shift-y" name="distance-y" value="0" min="-250" max="250" aria-label="Y offset between red and black icon" title="Vertical offset between red and black icons (positive = black down, red up)">
			<label for="input-range-scale-black">Black Scale</label>
			<input type="range" id="input-range-scale-black" name="scale-black" value="0" min="-3" max="3" step="0.01" aria-label="Scale factor for black icon" title="Scale factor for black icon (0 = 100%, negative = smaller, positive = larger)">
			<label for="input-range-scale-red">Red Scale</label>
			<input type="range" id="input-range-scale-red" name="scale-red" value="0" min="-3" max="3" step="0.01" aria-label="Scale factor for red icon" title="Scale factor for red icon (0 = 100%, negative = smaller, positive = larger)">
			<label for="input-file-icon-black">Black Icon (black+white+alpha only)</label>
			<input type="file" id="input-file-icon-black" name="icon-black" accept="image/*" aria-label="Upload black icon">
			<label for="input-file-icon-red">Red Icon (black+white+alpha only)</label>
			<input type="file" id="input-file-icon-red" name="icon-red" accept="image/*" aria-label="Upload red icon">
			<label for="input-range-bleed">Bleed (black in download)</label>
			<input type="range" id="input-range-bleed" name="bleed" value="0" min="0" max="50" aria-label="Bleed for printing" title="Add bleed area for printing (extra border that gets cut off, appears as black border in download)">
			<div class="checkbox-group">
				<div class="checkbox-item">
					<input type="checkbox" id="input-check-swap-red-black" name="swap-red-black" aria-label="Red on top of black">
					<label for="input-check-swap-red-black">Red on top of black</label>
				</div>
				<div class="checkbox-item">
					<input type="checkbox" id="input-check-lock-scale" name="lock-scale" aria-label="Same scale for red and black">
					<label for="input-check-lock-scale">Same scale for red and black</label>
				</div>
			</div>
			<div class="button-group">
				<div class="button-row">
					<input type="button" id="input-button-download" value="Download SVG" aria-label="Download sticker as SVG">
					<input type="button" id="input-button-download-png" value="Download PNG" aria-label="Download sticker as PNG">
				</div>
				<div class="button-row">
					<input type="button" id="input-button-reset" value="Reset Positions" aria-label="Reset all positions and scales to default values">
					<input type="button" id="input-button-save" value="Save Design" aria-label="Save current design to browser storage">
					<input type="button" id="input-button-load" value="Load Design" aria-label="Load saved design from browser storage">
				</div>
			</div>
			<label for="input-file-import-svg">Import downloaded SVG</label>
			<input type="file" id="input-file-import-svg" name="import-svg" accept="image/svg+xml" aria-label="Import previously downloaded SVG">
		</form>
		<script>
			'use strict';
			
			// Constants
			const XLINK_NS = 'http://www.w3.org/1999/xlink';
			const DEFAULT_SIZE = 500;
			const DEFAULT_ICON_SIZE = 512;
			const DEBOUNCE_DELAY = 16; // ~60fps
			
			// Default values
			const DEFAULTS = {
				textUpper: 'ANTIFASCHISTISCHE',
				textLower: 'AKTION',
				positionX: -9,
				positionY: -2,
				shiftX: 0,
				shiftY: 0,
				scaleBlack: 0,
				scaleRed: 0,
				bleed: 0,
				scaleFactor: 1, // scale value 0 = 10^0 = 1
				pngDefaultSize: 2048,
				pngMaxSize: 8192
			};
			
			// Helper: Convert scale input to actual scale value
			const scaleValueToNumber = (scaleInput) => Math.pow(10, Number(scaleInput));
			
			// Stroke colors for bleed circle
			const BLEED_STROKE_DEFAULT = '#ff00ff';
			const BLEED_STROKE_EXPORT = 'black';

			// DOM elements
			const doc = document.getElementById('svg');
			if (!doc) throw new Error('SVG element not found');
			
			const svgRoot = doc.getElementById("svgroot");
			const iconContainer = doc.getElementById("icon");
			const iconBlack = doc.getElementById("iconblack");
			const iconRed = doc.getElementById("iconred");
			const upperText = doc.getElementById("uppertext");
			const lowerText = doc.getElementById("lowertext");
			const bleedCircle = doc.getElementById("bleed");
			
			if (!svgRoot || !iconContainer || !iconBlack || !iconRed || !upperText || !lowerText || !bleedCircle) {
				throw new Error('Required SVG elements not found');
			}
			
			// Debounce helper
			function debounce(func, wait) {
				let timeout;
				return function executedFunction(...args) {
					const later = () => {
						clearTimeout(timeout);
						func(...args);
					};
					clearTimeout(timeout);
					timeout = setTimeout(later, wait);
				};
			}

			// Set version in header
			const versionHeader = document.getElementById('version-header');
			if (versionHeader) {
				versionHeader.textContent = `Antifa Sticker Generator ${VERSION}`;
			}

			// Dark mode functionality
			const darkModeToggle = document.getElementById('dark-mode-toggle');
			const STORAGE_KEY = 'darkMode';
			const THEME_ATTRIBUTE = 'data-theme';
			const DESIGN_STORAGE_KEY = 'antifaStickerDesign';
			
			function initDarkMode() {
				const savedTheme = localStorage.getItem(STORAGE_KEY);
				const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
				const isDark = savedTheme === 'dark' || (!savedTheme && prefersDark);
				setDarkMode(isDark);
			}
			
			function setDarkMode(isDark) {
				if (isDark) {
					document.documentElement.setAttribute(THEME_ATTRIBUTE, 'dark');
					if (darkModeToggle) darkModeToggle.textContent = 'â˜€ï¸';
					localStorage.setItem(STORAGE_KEY, 'dark');
				} else {
					document.documentElement.removeAttribute(THEME_ATTRIBUTE);
					if (darkModeToggle) darkModeToggle.textContent = 'ðŸŒ™';
					localStorage.setItem(STORAGE_KEY, 'light');
				}
			}
			
			function toggleDarkMode() {
				const isDark = document.documentElement.getAttribute(THEME_ATTRIBUTE) === 'dark';
				setDarkMode(!isDark);
			}
			
			// Initialize dark mode on page load
			initDarkMode();
			
			// Add click handler
			if (darkModeToggle) {
				darkModeToggle.addEventListener('click', toggleDarkMode);
			}
			
			// Listen for system theme changes
			window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
				if (!localStorage.getItem(STORAGE_KEY)) {
					setDarkMode(e.matches);
				}
			});

			// Service Worker Registration for PWA
			if ('serviceWorker' in navigator) {
				window.addEventListener('load', () => {
					navigator.serviceWorker.register('./sw.js', { scope: './' })
						.then((registration) => {
							// Check for updates
							registration.addEventListener('updatefound', () => {
								const newWorker = registration.installing;
								if (!newWorker) return;
								
								newWorker.addEventListener('statechange', () => {
									if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
										// New service worker available, prompt user to reload
										if (confirm('New version available. Reload to update?')) {
											window.location.reload();
										}
									}
								});
							});
							
							// Check for updates periodically (stored in variable for cleanup)
							const updateInterval = setInterval(() => {
								registration.update();
							}, 300000); // Check every 5 minutes (less aggressive)
						})
						.catch(() => {
							// Silent fail - app works without service worker
						});
				});
			}

			// Input elements - safely get all inputs with null checks
			const getElementById = (id) => document.getElementById(id);
			const inputs = {
				textUpper: getElementById("input-text-upper"),
				textLower: getElementById("input-text-lower"),
				positionX: getElementById("input-range-position-x"),
				positionY: getElementById("input-range-position-y"),
				shiftX: getElementById("input-range-shift-x"),
				shiftY: getElementById("input-range-shift-y"),
				scaleBlack: getElementById("input-range-scale-black"),
				scaleRed: getElementById("input-range-scale-red"),
				fileIconBlack: getElementById("input-file-icon-black"),
				fileIconRed: getElementById("input-file-icon-red"),
				checkSwap: getElementById("input-check-swap-red-black"),
				checkLockScale: getElementById("input-check-lock-scale"),
				bleed: getElementById("input-range-bleed"),
				buttonDownload: getElementById("input-button-download"),
				buttonDownloadPng: getElementById("input-button-download-png"),
				fileImportSvg: getElementById("input-file-import-svg"),
				buttonReset: getElementById("input-button-reset"),
				buttonSave: getElementById("input-button-save"),
				buttonLoad: getElementById("input-button-load")
			};

			// Helper functions - optimized DOM operations
			function setImageHref(imgElement, dataUrl, width, height) {
				if (!imgElement) return;
				// Use baseVal for better performance when possible
				imgElement.href.baseVal = dataUrl;
				imgElement.setAttributeNS(XLINK_NS, 'href', dataUrl);
				if (width) imgElement.width.baseVal.value = width;
				if (height) imgElement.height.baseVal.value = height;
			}

			// Transform update helpers
			function getIconTransform(iconElement, index) {
				if (!iconElement) return null;
				const transforms = iconElement.transform.baseVal;
				if (transforms.numberOfItems <= index) return null;
				return transforms[index].matrix;
			}

			function updateIconPosition(iconElement, x, y) {
				const matrix = getIconTransform(iconElement, 1);
				if (!matrix) return;
				matrix.e = x;
				matrix.f = y;
			}

			function updateIconShift(iconElement, x, y, invert = false) {
				const matrix = getIconTransform(iconElement, 0);
				if (!matrix) return;
				matrix.e = invert ? -x : x;
				matrix.f = invert ? -y : y;
			}

			function updateIconScale(iconElement, scale) {
				const matrix = getIconTransform(iconElement, 2);
				if (!matrix) return;
				matrix.a = scale;
				matrix.d = scale;
			}

			function getIconPosition(iconElement) {
				const matrix = getIconTransform(iconElement, 1);
				return matrix ? { x: matrix.e, y: matrix.f } : { x: 0, y: 0 };
			}

			function getIconShift(iconElement) {
				const matrix = getIconTransform(iconElement, 0);
				return matrix ? { x: matrix.e, y: matrix.f } : { x: 0, y: 0 };
			}

			function updateBleed(bleedVal) {
				if (!bleedCircle || !doc) return;
				// Batch DOM updates
				const size = DEFAULT_SIZE + bleedVal * 2;
				const viewBox = doc.viewBox.baseVal;
				bleedCircle.style.strokeWidth = bleedVal === 0 ? '0' : `${bleedVal * 2 + 1}`;
				doc.width.baseVal.value = size;
				doc.height.baseVal.value = size;
				viewBox.x = -bleedVal;
				viewBox.y = -bleedVal;
				viewBox.width = size;
				viewBox.height = size;
			}

			function resizeSvg(size, offset) {
				if (!doc || !svgRoot) return;
				const scale = size / DEFAULT_SIZE;
				// Batch DOM updates
				const viewBox = doc.viewBox.baseVal;
				doc.width.baseVal.value = size;
				doc.height.baseVal.value = size;
				viewBox.width = size;
				viewBox.height = size;
				viewBox.x = offset;
				viewBox.y = offset;
				if (svgRoot.transform.baseVal.numberOfItems > 0) {
					const matrix = svgRoot.transform.baseVal[0].matrix;
					matrix.a = scale;
					matrix.d = scale;
				}
			}

			function restoreSvgSize(originalSize, originalOffset) {
				if (!doc || !svgRoot) return;
				// Batch DOM updates
				const viewBox = doc.viewBox.baseVal;
				doc.width.baseVal.value = originalSize;
				doc.height.baseVal.value = originalSize;
				viewBox.width = originalSize;
				viewBox.height = originalSize;
				viewBox.x = originalOffset;
				viewBox.y = originalOffset;
				if (svgRoot.transform.baseVal.numberOfItems > 0) {
					const matrix = svgRoot.transform.baseVal[0].matrix;
					matrix.a = 1;
					matrix.d = 1;
				}
			}

			function loadImageFile(file, targetElement) {
				if (!file || !targetElement) return;
				
				// Validate file type
				if (!file.type.startsWith('image/')) {
					alert('Please select a valid image file.');
					return;
				}
				
				const reader = new FileReader();
				reader.onerror = () => {
					alert('Error reading image file. Please try again.');
				};
				reader.onabort = () => {
					// File read was cancelled, silently handle
				};
				reader.onload = (e) => {
					if (!e.target?.result) return;
					
					const img = new Image();
					img.crossOrigin = 'anonymous';
					img.onerror = () => {
						alert('Error loading image. Please ensure it is a valid image format.');
					};
					img.onload = () => {
						const width = img.width || Number(targetElement.width?.baseVal?.value) || DEFAULT_ICON_SIZE;
						const height = img.height || Number(targetElement.height?.baseVal?.value) || DEFAULT_ICON_SIZE;
						setImageHref(targetElement, e.target.result, width, height);
					};
					img.onabort = () => {
						// Image load was cancelled
					};
					img.src = e.target.result;
				};
				reader.readAsDataURL(file);
			}

			function serializeSvg() {
				return new XMLSerializer().serializeToString(doc);
			}

			function createSvgDataUrl(svgString) {
				const xmlDeclaration = '<?xml version="1.0" encoding="utf-8"?>';
				const fullSvg = xmlDeclaration + '\n' + svgString;
				return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(fullSvg);
			}
			
			// Validate numeric input
			function isValidNumber(value, min = -Infinity, max = Infinity) {
				const num = Number(value);
				return !Number.isNaN(num) && num >= min && num <= max;
			}

			// Text input handlers - optimized with direct assignment
			function updateTextElement(inputElement, textElement) {
				if (inputElement && textElement) {
					textElement.textContent = inputElement.value || '';
				}
			}

			if (inputs.textUpper) {
				inputs.textUpper.oninput = () => updateTextElement(inputs.textUpper, upperText);
			}

			if (inputs.textLower) {
				inputs.textLower.oninput = () => updateTextElement(inputs.textLower, lowerText);
			}

			// Position updates - optimized to update both icons together
			function updateBothIconsPosition(x, y) {
				updateIconPosition(iconBlack, x, y);
				updateIconPosition(iconRed, x, y);
			}

			const updatePositionX = () => {
				if (!inputs.positionX) return;
				const value = Number(inputs.positionX.value);
				if (!isValidNumber(value)) return;
				const blackPos = getIconPosition(iconBlack);
				updateBothIconsPosition(value, blackPos.y);
			};
			if (inputs.positionX) {
				inputs.positionX.oninput = debounce(updatePositionX, DEBOUNCE_DELAY);
			}

			const updatePositionY = () => {
				if (!inputs.positionY) return;
				const value = Number(inputs.positionY.value);
				if (!isValidNumber(value)) return;
				const blackPos = getIconPosition(iconBlack);
				updateBothIconsPosition(blackPos.x, value);
			};
			if (inputs.positionY) {
				inputs.positionY.oninput = debounce(updatePositionY, DEBOUNCE_DELAY);
			}

			// Shift updates - optimized to update both icons together
			function updateBothIconsShift(x, y) {
				updateIconShift(iconBlack, x, y, false);
				updateIconShift(iconRed, x, y, true);
			}

			const updateShiftX = () => {
				if (!inputs.shiftX) return;
				const value = Number(inputs.shiftX.value);
				if (!isValidNumber(value)) return;
				const blackShift = getIconShift(iconBlack);
				updateBothIconsShift(value, blackShift.y);
			};
			if (inputs.shiftX) {
				inputs.shiftX.oninput = debounce(updateShiftX, DEBOUNCE_DELAY);
			}

			const updateShiftY = () => {
				if (!inputs.shiftY) return;
				const value = Number(inputs.shiftY.value);
				if (!isValidNumber(value)) return;
				const blackShift = getIconShift(iconBlack);
				updateBothIconsShift(blackShift.x, value);
			};
			if (inputs.shiftY) {
				inputs.shiftY.oninput = debounce(updateShiftY, DEBOUNCE_DELAY);
			}

			// Scale updates
			const updateScaleBlack = () => {
				if (!inputs.scaleBlack) return;
				const scale = scaleValueToNumber(inputs.scaleBlack.value);
				updateIconScale(iconBlack, scale);
				if (inputs.checkLockScale?.checked) {
					updateIconScale(iconRed, scale);
				}
			};
			if (inputs.scaleBlack) {
				inputs.scaleBlack.oninput = debounce(updateScaleBlack, DEBOUNCE_DELAY);
			}

			const updateScaleRed = () => {
				if (!inputs.scaleRed || inputs.checkLockScale?.checked) return;
				const scale = scaleValueToNumber(inputs.scaleRed.value);
				updateIconScale(iconRed, scale);
			};
			if (inputs.scaleRed) {
				inputs.scaleRed.oninput = debounce(updateScaleRed, DEBOUNCE_DELAY);
			}

			// File input handlers
			if (inputs.fileIconBlack) {
				inputs.fileIconBlack.onchange = (e) => {
					loadImageFile(e.target.files?.[0], iconBlack);
				};
			}

			if (inputs.fileIconRed) {
				inputs.fileIconRed.onchange = (e) => {
					loadImageFile(e.target.files?.[0], iconRed);
				};
			}

			// Checkbox handlers
			if (inputs.checkSwap) {
				inputs.checkSwap.onchange = () => {
					const first = inputs.checkSwap.checked ? iconBlack : iconRed;
					const second = inputs.checkSwap.checked ? iconRed : iconBlack;
					iconContainer.insertBefore(first, second);
				};
			}

			if (inputs.checkLockScale) {
				inputs.checkLockScale.onchange = () => {
					if (inputs.scaleRed) {
						inputs.scaleRed.disabled = inputs.checkLockScale.checked;
					}
					if (inputs.checkLockScale.checked && inputs.scaleBlack) {
						const scale = scaleValueToNumber(inputs.scaleBlack.value);
						updateIconScale(iconRed, scale);
					} else if (inputs.scaleRed) {
						const redScale = scaleValueToNumber(inputs.scaleRed.value);
						updateIconScale(iconRed, redScale);
					}
				};
			}

			// Bleed handler
			const updateBleedHandler = () => {
				if (inputs.bleed) {
					updateBleed(parseInt(inputs.bleed.value, 10));
				}
			};
			if (inputs.bleed) {
				inputs.bleed.oninput = debounce(updateBleedHandler, DEBOUNCE_DELAY);
			}

			// Reset function - optimized with batched updates
			function resetPositions() {
				// Reset text values
				if (inputs.textUpper) {
					inputs.textUpper.value = DEFAULTS.textUpper;
					updateTextElement(inputs.textUpper, upperText);
				}
				if (inputs.textLower) {
					inputs.textLower.value = DEFAULTS.textLower;
					updateTextElement(inputs.textLower, lowerText);
				}

				// Reset positions - use optimized function
				if (inputs.positionX) inputs.positionX.value = DEFAULTS.positionX;
				if (inputs.positionY) inputs.positionY.value = DEFAULTS.positionY;
				updateBothIconsPosition(DEFAULTS.positionX, DEFAULTS.positionY);

				// Reset shifts - use optimized function
				if (inputs.shiftX) inputs.shiftX.value = DEFAULTS.shiftX;
				if (inputs.shiftY) inputs.shiftY.value = DEFAULTS.shiftY;
				updateBothIconsShift(DEFAULTS.shiftX, DEFAULTS.shiftY);

				// Reset scales
				if (inputs.scaleBlack) {
					inputs.scaleBlack.value = DEFAULTS.scaleBlack;
					updateIconScale(iconBlack, DEFAULTS.scaleFactor);
				}
				if (inputs.scaleRed) {
					inputs.scaleRed.value = DEFAULTS.scaleRed;
					updateIconScale(iconRed, DEFAULTS.scaleFactor);
				}

				// Reset bleed
				if (inputs.bleed) {
					inputs.bleed.value = DEFAULTS.bleed;
					updateBleed(DEFAULTS.bleed);
				}

				// Reset checkboxes
				if (inputs.checkSwap) {
					inputs.checkSwap.checked = false;
					iconContainer.insertBefore(iconRed, iconBlack);
				}
				if (inputs.checkLockScale) {
					inputs.checkLockScale.checked = false;
					if (inputs.scaleRed) inputs.scaleRed.disabled = false;
				}
			}

			// Download helpers - optimized DOM manipulation
			function downloadFile(dataUrl, filename) {
				const link = document.createElement('a');
				link.href = dataUrl;
				link.download = filename;
				link.style.display = 'none';
				document.body.appendChild(link);
				link.click();
				// Cleanup after a short delay to ensure download starts
				setTimeout(() => document.body.removeChild(link), 100);
			}

			// Download handlers
			if (inputs.buttonDownload) {
				inputs.buttonDownload.onclick = () => {
					bleedCircle.style.stroke = BLEED_STROKE_EXPORT;
					const serialized = serializeSvg();
					bleedCircle.style.stroke = BLEED_STROKE_DEFAULT;
					downloadFile(createSvgDataUrl(serialized), 'antifa.svg');
				};
			}

			// Reset handler
			if (inputs.buttonReset) {
				inputs.buttonReset.onclick = () => {
					resetPositions();
				};
			}

			// Drag and drop functionality for icons
			let isDragging = false;
			let dragTarget = null;
			let dragStartX = 0;
			let dragStartY = 0;
			let initialX = 0;
			let initialY = 0;

			// Cache SVG transforms for better performance
			let svgCTM = null;
			let svgCTMInverse = null;
			
			function getSVGPoint(event) {
				// Cache CTM (Coordinate Transformation Matrix) for performance
				if (!svgCTMInverse) {
					svgCTM = doc.getScreenCTM();
					svgCTMInverse = svgCTM ? svgCTM.inverse() : null;
				}
				const svgRect = doc.getBoundingClientRect();
				const point = doc.createSVGPoint();
				point.x = event.clientX - svgRect.left;
				point.y = event.clientY - svgRect.top;
				return svgCTMInverse ? point.matrixTransform(svgCTMInverse) : point;
			}
			
			// Reset CTM cache on window resize
			window.addEventListener('resize', () => {
				svgCTM = null;
				svgCTMInverse = null;
			}, { passive: true });

			function startDrag(event, targetIcon) {
				if (event.button !== 0 && event.type !== 'touchstart') return; // Only left mouse button
				event.preventDefault();
				isDragging = true;
				dragTarget = targetIcon;
				const point = getSVGPoint(event);
				dragStartX = point.x;
				dragStartY = point.y;
				const pos = getIconPosition(targetIcon);
				initialX = pos.x;
				initialY = pos.y;
				doc.style.cursor = 'grabbing';
			}

			function onDrag(event) {
				if (!isDragging || !dragTarget) return;
				event.preventDefault();
				const point = getSVGPoint(event);
				const deltaX = point.x - dragStartX;
				const deltaY = point.y - dragStartY;
				
				const newX = initialX + deltaX;
				const newY = initialY + deltaY;
				
				// Update both icons position (they share position)
				updateBothIconsPosition(newX, newY);
				
				// Update input sliders
				if (inputs.positionX) inputs.positionX.value = Math.round(newX);
				if (inputs.positionY) inputs.positionY.value = Math.round(newY);
			}

			function endDrag(event) {
				if (!isDragging) return;
				event.preventDefault();
				isDragging = false;
				dragTarget = null;
				doc.style.cursor = '';
			}

			// Add drag handlers to icons - use event delegation for better performance
			const iconElements = [iconBlack, iconRed].filter(Boolean);
			iconElements.forEach(icon => {
				icon.addEventListener('mousedown', (e) => startDrag(e, icon), { passive: false });
				icon.addEventListener('touchstart', (e) => startDrag(e.touches[0], icon), { passive: false });
			});

			// Use passive listeners where possible for better performance
			doc.addEventListener('mousemove', onDrag, { passive: false });
			doc.addEventListener('touchmove', (e) => {
				if (e.touches.length === 1) onDrag(e.touches[0]);
			}, { passive: false });
			doc.addEventListener('mouseup', endDrag);
			doc.addEventListener('mouseleave', endDrag);
			doc.addEventListener('touchend', endDrag);
			doc.addEventListener('touchcancel', endDrag);

			// LocalStorage save/load functionality - optimized with helper
			function getInputValue(input, defaultValue) {
				return input ? (typeof defaultValue === 'number' ? Number(input.value) || defaultValue : input.value || defaultValue) : defaultValue;
			}

			function saveDesign() {
				try {
					const design = {
						textUpper: getInputValue(inputs.textUpper, DEFAULTS.textUpper),
						textLower: getInputValue(inputs.textLower, DEFAULTS.textLower),
						positionX: getInputValue(inputs.positionX, DEFAULTS.positionX),
						positionY: getInputValue(inputs.positionY, DEFAULTS.positionY),
						shiftX: getInputValue(inputs.shiftX, DEFAULTS.shiftX),
						shiftY: getInputValue(inputs.shiftY, DEFAULTS.shiftY),
						scaleBlack: getInputValue(inputs.scaleBlack, DEFAULTS.scaleBlack),
						scaleRed: getInputValue(inputs.scaleRed, DEFAULTS.scaleRed),
						bleed: getInputValue(inputs.bleed, DEFAULTS.bleed),
						swapOrder: inputs.checkSwap?.checked || false,
						lockScale: inputs.checkLockScale?.checked || false,
						iconBlack: iconBlack?.href?.baseVal || '',
						iconRed: iconRed?.href?.baseVal || ''
					};
					localStorage.setItem(DESIGN_STORAGE_KEY, JSON.stringify(design));
					alert('Design saved successfully!');
				} catch (e) {
					alert('Error saving design: ' + (e.message || 'Unknown error'));
				}
			}

			function loadDesign() {
				try {
					const saved = localStorage.getItem(DESIGN_STORAGE_KEY);
					if (!saved) {
						alert('No saved design found.');
						return;
					}
					const design = JSON.parse(saved);
					
					// Load text - use optimized function
					if (inputs.textUpper && design.textUpper) {
						inputs.textUpper.value = design.textUpper;
						updateTextElement(inputs.textUpper, upperText);
					}
					if (inputs.textLower && design.textLower) {
						inputs.textLower.value = design.textLower;
						updateTextElement(inputs.textLower, lowerText);
					}
					
					// Load positions - use optimized function
					const posX = design.positionX ?? DEFAULTS.positionX;
					const posY = design.positionY ?? DEFAULTS.positionY;
					if (inputs.positionX) inputs.positionX.value = posX;
					if (inputs.positionY) inputs.positionY.value = posY;
					updateBothIconsPosition(posX, posY);
					
					// Load shifts - use optimized function
					const shiftX = design.shiftX ?? DEFAULTS.shiftX;
					const shiftY = design.shiftY ?? DEFAULTS.shiftY;
					if (inputs.shiftX) inputs.shiftX.value = shiftX;
					if (inputs.shiftY) inputs.shiftY.value = shiftY;
					updateBothIconsShift(shiftX, shiftY);
					
					// Load scales
					if (inputs.scaleBlack && design.scaleBlack !== undefined) {
						inputs.scaleBlack.value = design.scaleBlack;
						const scale = scaleValueToNumber(design.scaleBlack);
						updateIconScale(iconBlack, scale);
					}
					if (inputs.scaleRed && design.scaleRed !== undefined) {
						inputs.scaleRed.value = design.scaleRed;
						const scale = scaleValueToNumber(design.scaleRed);
						updateIconScale(iconRed, scale);
					}
					
					// Load bleed
					if (inputs.bleed && design.bleed !== undefined) {
						inputs.bleed.value = design.bleed;
						updateBleed(design.bleed);
					}
					
					// Load checkboxes
					if (inputs.checkSwap && design.swapOrder !== undefined) {
						inputs.checkSwap.checked = design.swapOrder;
						const first = design.swapOrder ? iconBlack : iconRed;
						const second = design.swapOrder ? iconRed : iconBlack;
						iconContainer.insertBefore(first, second);
					}
					if (inputs.checkLockScale && design.lockScale !== undefined) {
						inputs.checkLockScale.checked = design.lockScale;
						if (inputs.scaleRed) {
							inputs.scaleRed.disabled = design.lockScale;
						}
					}
					
					// Load icons (if saved)
					if (design.iconBlack && iconBlack) {
						setImageHref(iconBlack, design.iconBlack);
					}
					if (design.iconRed && iconRed) {
						setImageHref(iconRed, design.iconRed);
					}
					
					alert('Design loaded successfully!');
				} catch (e) {
					alert('Error loading design: ' + (e.message || 'Unknown error'));
				}
			}

			// Save/Load handlers
			if (inputs.buttonSave) {
				inputs.buttonSave.onclick = saveDesign;
			}
			if (inputs.buttonLoad) {
				inputs.buttonLoad.onclick = loadDesign;
			}

			if (inputs.buttonDownloadPng) {
				inputs.buttonDownloadPng.onclick = async () => {
				const originalSize = Number(doc.width.baseVal.value);
				const originalOffset = Number(doc.viewBox.baseVal.x);
				const imgSizeInput = prompt(`Enter image size (e.g. ${DEFAULTS.pngDefaultSize})`, String(DEFAULTS.pngDefaultSize));
				
				if (!imgSizeInput) return;
				
				const imgSize = parseInt(imgSizeInput, 10);
				if (!isValidNumber(imgSize, 1, DEFAULTS.pngMaxSize)) {
					alert(`Invalid image size. Please enter a number between 1 and ${DEFAULTS.pngMaxSize}.`);
					return;
				}

				// Resize SVG for export
				bleedCircle.style.stroke = BLEED_STROKE_EXPORT;
				const offset = originalOffset * imgSize / originalSize;
				resizeSvg(imgSize, offset);

				// Clone and inline external images
				const clone = doc.cloneNode(true);
				let failures = 0;
				const images = clone.querySelectorAll('image');
				
				for (const imgEl of images) {
					try {
						const href = imgEl.getAttributeNS(XLINK_NS, 'href') || 
						              imgEl.getAttribute('href') || 
						              imgEl.href?.baseVal;
						if (!href || href.startsWith('data:')) continue;
						
						// Create abort controller for timeout
						const controller = new AbortController();
						const timeoutId = setTimeout(() => controller.abort(), 5000);
						const resp = await fetch(href, { mode: 'cors', signal: controller.signal });
						clearTimeout(timeoutId);
						if (!resp.ok) throw new Error('fetch failed');
						const blob = await resp.blob();
						const dataUrl = await new Promise((resolve, reject) => {
							const fr = new FileReader();
							fr.onload = () => resolve(fr.result);
							fr.onerror = reject;
							fr.onabort = reject;
							fr.readAsDataURL(blob);
						});
						imgEl.setAttributeNS(XLINK_NS, 'href', dataUrl);
					} catch (e) {
						failures++;
					}
				}

				// Restore original size
				bleedCircle.style.stroke = BLEED_STROKE_DEFAULT;
				restoreSvgSize(originalSize, originalOffset);

				const serialized = new XMLSerializer().serializeToString(clone);
				
				if (failures > 0) {
					alert(`Could not inline ${failures} external image(s) due to CORS. PNG export aborted. The SVG will open in a new tab; use "Download SVG" or host images with CORS enabled to export PNG.`);
					window.open(createSvgDataUrl(serialized), '_blank');
					return;
				}

				// Render to canvas
				const canvas = document.createElement('canvas');
				canvas.width = imgSize;
				canvas.height = imgSize;
				const ctx = canvas.getContext("2d");
				const image = new Image();
				image.crossOrigin = 'anonymous';
				image.onerror = () => {
					alert('Error loading SVG image. SVG opened in new tab as fallback.');
					window.open(createSvgDataUrl(serialized), '_blank');
					restoreSvgSize(originalSize, originalOffset);
				};
				image.onload = () => {
					try {
						ctx.drawImage(image, 0, 0);
						downloadFile(canvas.toDataURL('image/png'), 'antifa.png');
					} catch (e) {
						alert('Export to PNG failed during finalization: canvas may be tainted. Opened SVG in new tab as fallback.');
						window.open(createSvgDataUrl(serialized), '_blank');
					}
				};
				image.onabort = () => {
					restoreSvgSize(originalSize, originalOffset);
				};
				image.src = createSvgDataUrl(serialized);
				};
			}

			if (inputs.fileImportSvg) {
				inputs.fileImportSvg.onchange = (e) => {
				const file = e.target.files[0];
				if (!file) return;
				
				const reader = new FileReader();
				reader.onerror = () => {
					alert('Error reading file.');
				};
				reader.onload = (e) => {
					try {
						const parser = new DOMParser();
						const imported = parser.parseFromString(e.target.result, 'image/svg+xml');
						
						// Check for parsing errors
						const parserError = imported.querySelector('parsererror');
						if (parserError) {
							alert('Error parsing SVG. Please ensure it is a valid SVG file.');
							return;
						}
					
					// Import text - use optimized function
					const impUpperText = imported.getElementById('uppertext');
					const impLowerText = imported.getElementById('lowertext');
					if (impUpperText && inputs.textUpper) {
						inputs.textUpper.value = impUpperText.textContent || '';
						updateTextElement(inputs.textUpper, upperText);
					}
					if (impLowerText && inputs.textLower) {
						inputs.textLower.value = impLowerText.textContent || '';
						updateTextElement(inputs.textLower, lowerText);
					}

					// Import icons
					const impIconBlack = imported.getElementById('iconblack');
					const impIconRed = imported.getElementById('iconred');
					if (impIconBlack) {
						const href = impIconBlack.href.baseVal;
						setImageHref(iconBlack, href);
					}
					if (impIconRed) {
						const href = impIconRed.href.baseVal;
						setImageHref(iconRed, href);
					}

					// Import transforms
					if (impIconBlack && impIconBlack.transform.baseVal.numberOfItems >= 3) {
						const transforms = impIconBlack.transform.baseVal;
						// Shift - use optimized function
						const shiftMatrix = transforms[0].matrix;
						const shiftX = shiftMatrix.e;
						const shiftY = shiftMatrix.f;
						if (inputs.shiftX) inputs.shiftX.value = shiftX;
						if (inputs.shiftY) inputs.shiftY.value = shiftY;
						updateBothIconsShift(shiftX, shiftY);
						// Position - use optimized function
						const posMatrix = transforms[1].matrix;
						const posX = posMatrix.e;
						const posY = posMatrix.f;
						if (inputs.positionX) inputs.positionX.value = posX;
						if (inputs.positionY) inputs.positionY.value = posY;
						updateBothIconsPosition(posX, posY);
						// Scale
						const scaleMatrix = transforms[2].matrix;
						const scaleBlack = scaleMatrix.a;
						if (inputs.scaleBlack) {
							inputs.scaleBlack.value = Math.log10(scaleBlack);
						}
						updateIconScale(iconBlack, scaleBlack);
					}
					if (impIconRed && impIconRed.transform.baseVal.numberOfItems >= 3) {
						const scaleMatrix = impIconRed.transform.baseVal[2].matrix;
						const scaleRed = scaleMatrix.a;
						if (inputs.scaleRed) {
							inputs.scaleRed.value = Math.log10(scaleRed);
						}
						updateIconScale(iconRed, scaleRed);
					}

					// Import swap order
					const impIconContainer = imported.getElementById('icon');
					if (impIconContainer && impIconContainer.children[0]?.id === 'iconblack') {
						inputs.checkSwap.checked = true;
						iconContainer.insertBefore(iconBlack, iconRed);
					} else {
						inputs.checkSwap.checked = false;
						iconContainer.insertBefore(iconRed, iconBlack);
					}

					// Import bleed
					const impBleed = imported.getElementById('bleed');
					if (impBleed) {
						const bleedVal = Math.max(parseInt(impBleed.style.strokeWidth, 10) - 1, 0);
						inputs.bleed.value = bleedVal;
						updateBleed(bleedVal);
					}
					} catch (error) {
						alert('Error importing SVG: ' + (error.message || 'Unknown error occurred'));
					}
				};
				reader.readAsText(file);
				};
			}
		</script>
	</body>
</html>
